// Slowly building a lexer using pettyscript.

struct Lexer { str, remaining }

enum Token {
    LParen,
    RParen,
    LBrace,
    RBrace,
    LBracket,
    RBracket,
    Comma,
    Dot,
    Bang,
    Semicolon,
    Colon,
    Plus,
    Minus,
    Star,
    Slash,
    Percent,
    Pipe,
    Ampersand,
    RAngle,
    LAngle,
    RAngleEq,
    LAngleEq,
    Eq,
    EqEq,
    BangEq,
    Range,
    RangeInclusive,
    // Keywords
    Or,
    And,
    If,
    Else,
    In,
    Fn,
    For,
    Break,
    Return,
    Struct,
    Enum,
    // Literals
    Int,
    Character,
    String,
    Ident,
}

fn lexer_next(lexer) {
    lexer.remaining = trim(lexer.remaining);
    const first_char = lexer.remaining[0];
    let token;

    while true {
        let skip = 1;

        if starts_with(lexer.remaining, "//") {
            let i = 2;
            while i < str_len(lexer.remaining) && lexer.remaining[i] != "\n" {
                i = i + 1;
            }
            lexer.remaining = lexer.remaining[i..str_len(lexer.remaining)];
            continue;
        }
        // Keywords
        else if starts_with(lexer.remaining, "or") { token = Token.Or; skip = 2; }
        else if starts_with(lexer.remaining, "||") { token = Token.Or; skip = 2; }
        else if starts_with(lexer.remaining, "and") { token = Token.And; skip = 3; }
        else if starts_with(lexer.remaining, "&&") { token = Token.And; skip = 2; }
        else if starts_with(lexer.remaining, "if") { token = Token.If; skip = 2; }
        else if starts_with(lexer.remaining, "else") { token = Token.Else; skip = 4; }
        else if starts_with(lexer.remaining, "in") { token = Token.In; skip = 2; }
        else if starts_with(lexer.remaining, "fn") { token = Token.Fn; skip = 2; }
        else if starts_with(lexer.remaining, "for") { token = Token.For; skip = 3; }
        else if starts_with(lexer.remaining, "break") { token = Token.Break; skip = 5; }
        else if starts_with(lexer.remaining, "return") { token = Token.Return; skip = 6; }
        else if starts_with(lexer.remaining, "struct") { token = Token.Struct; skip = 6; }
        else if starts_with(lexer.remaining, "enum") { token = Token.Enum; skip = 4; }
        // Symbols
        else if starts_with(lexer.remaining, "==") { token = Token.EqEq; skip = 2; }
        else if starts_with(lexer.remaining, "!=") { token = Token.BangEq; skip = 2; }
        else if starts_with(lexer.remaining, "<=") { token = Token.LAngleEq; skip = 2; }
        else if starts_with(lexer.remaining, ">=") { token = Token.RAngleEq; skip = 2; }
        else if starts_with(lexer.remaining, "..") { token = Token.Range; skip = 2; }
        else if starts_with(lexer.remaining, "..=") { token = Token.RangeInclusive; skip = 3; }else if first_char == '[' { token = Token.LBracket; }
        else if first_char == ']' { token = Token.RBracket; }
        else if first_char == '(' { token = Token.LParen; }
        else if first_char == ')' { token = Token.RParen; }
        else if first_char == '{' { token = Token.LBrace; }
        else if first_char == '}' { token = Token.RBrace; }
        else if first_char == '<' { token = Token.LAngle; }
        else if first_char == '>' { token = Token.RAngle; }
        else if first_char == ';' { token = Token.Semicolon; }
        else if first_char == ':' { token = Token.Colon; }
        else if first_char == ',' { token = Token.Comma; }
        else if first_char == '.' { token = Token.Dot; }
        else if first_char == '+' { token = Token.Plus; }
        else if first_char == '-' { token = Token.Minus; }
        else if first_char == '*' { token = Token.Star; }
        else if first_char == '/' { token = Token.Slash; }
        else if first_char == '%' { token = Token.Percent; }
        else if first_char == '|' { token = Token.Pipe; }
        else if first_char == '&' { token = Token.Ampersand; }
        else if first_char == '=' { token = Token.Eq; }
        // Literals
        else if is_digit(first_char) || first_char == '_' {
            while is_digit(lexer.remaining[skip]) {
                skip = skip + 1;
            }
            token = Token.Int;
        }
        else if first_char == "'" {
            skip = skip + 2;
            token = Token.Character;
        } 
        else if first_char == '"' {
            while lexer.remaining[skip] != '"' {
                skip = skip + 1;
            }
            skip = skip + 1;
            token = Token.String;
        } else if is_alphabetical(first_char) {
            while is_alphabetical(lexer.remaining[skip]) {
                skip = skip + 1;
            }
            token = Token.Ident;
        } else {
            // TODO: f strings
            println("Invalid Symbol: {}");
            println(first_char);
            exit(1);
        }
        lexer.remaining = lexer.remaining[skip..str_len(lexer.remaining)];
        return token;
    } 
}

fn main() {
    let str = read_file("examples/fizzbuzz.pty");
    let lexer = Lexer { str, remaining: str };
    while true {
        let token = lexer_next(lexer);
        println(token);
        if lexer.remaining == "" {
            break;
        }
    }
}
